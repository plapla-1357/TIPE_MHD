import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

plt.rcParams.update({'font.size': 18})

def getFile(name:str):
    # le fichier doit etre prealablement formaté
    data = pd.read_csv(name)
    data.head()
    data = data.dropna()
    data = data.reset_index(drop=True)
    # print(data)
    return data

def norme(data):
    return np.sqrt(data["x"]**2 + data["y"]**2)

def normeXY(X, Y):
    return np.sqrt(X**2 + Y**2)

def filtreMoy(X, n):
    def moy(l):
        return sum(l)/len(l)
    return np.array([X[i] if i<=n or i>=len(X)-n else moy(X[i-n:i+n]) for i in range(len(X))])

def integre(X, T, n):
    return np.array([(X[i-n] - X[i+n])/(T[i-n] - T[i+n]) for i in range(n, len(X)-n)])

def integreXY(X, Y, T, n):
    v_x = integre(X, T, n)
    v_y = integre(Y, T, n)
    return normeXY(v_x, v_y)

def reg(*args):
    def reg2(x):
        return sum([args[i]*x**(len(args) - i -1) for i in range(len(args))])
    return reg2

def linear_regOrignStart(X, Y, n):
    i_start = next((i for i, x in enumerate(X) if x > 0), None)
    if i_start is None:
        raise ValueError("No positive value found in X.")
    return np.polyfit(X[i_start:], Y[i_start:], n)

from matplotlib.pyplot import show


def compare_data3(ids: list[int], experiences: pd.DataFrame, exp_datas, variable:str, desc="" ,showSpeed=False) -> None:
    # Figure for velocity curves
    if showSpeed:
        plt.figure(figsize=(12, 6))
        for i, id in enumerate(ids):
            plt.subplot(1, len(ids), i + 1)
            data = exp_datas[id]
            for j in range(len(data)):
                t_debut = experiences.loc[experiences["id"] == id, "t_debut"].iloc[0][j] if experiences.loc[experiences["id"] == id, "t_debut"].iloc[0] else 0
                if t_debut == None: 
                    t_debut = 0
                vitesse = integreXY(data[j]["x"], data[j]["y"], data[0]["t"], 10)
                T = data[0]["t"][10:-10] - t_debut
                a, b = linear_regOrignStart(T, vitesse, 1)
                plt.plot(T, vitesse, label=f"Pointage {j + 1}")
                plt.plot(T, reg(a, b)(T), "--", label=f"y = {a:.6f}x + {b:.6f}")
            plt.title(f"Vitesse pour ID {id}")
            plt.xlabel("Temps (s)")
            plt.ylabel("Vitesse ($m.s^{-1}$)")
            plt.legend()
            plt.grid()
    
    # Figure for slopes and accelerations
    plt.figure(figsize=(12, 6))
    variableValue = []
    slopes = []
    means = []
    stds = []
    ids_for_points = []
    for id in ids:
        data = exp_datas[id]
        id_slopes = []
        for j in range(len(data)):
            t_debut = experiences.loc[experiences["id"] == id, "t_debut"].iloc[0][j] if experiences.loc[experiences["id"] == id, "t_debut"].iloc[0] else 0
            if t_debut == None: 
                t_debut = 0
            T = data[j]["t"][10:-10] - t_debut
            vitesse = integreXY(data[j]["x"], data[j]["y"], data[j]["t"], 10)
            a, _ = linear_regOrignStart(T, vitesse, 1)
            # a = abs(a)
            slopes.append(a)
            id_slopes.append(a)
            variableValue.append(experiences.loc[experiences["id"] == id, variable].iloc[0])
            ids_for_points.append(id)
        means.append(np.mean(id_slopes))
        stds.append(np.std(id_slopes))
    a, b = np.polyfit(variableValue, slopes, 1)
    plt.plot(variableValue, reg(a, b)(np.array(variableValue)), "--", label=f"y = {a:.6f}x + {b:.6f}")
    plt.errorbar([experiences.loc[experiences["id"] == id, variable].iloc[0] for id in ids], means, yerr=STDM, fmt='g+', capsize=5, label="Écart-type Moyen")
    plt.errorbar([experiences.loc[experiences["id"] == id, variable].iloc[0] for id in ids], means, yerr=stds, fmt='r+', capsize=6, label="Écart-type")
    plt.plot(variableValue, slopes, "o", label="Pentes des droites")
    # Ajouter l'id de l'expérience sur chaque point
    for x, y, id_val in zip(variableValue, slopes, ids_for_points):
        plt.annotate(str(id_val), (x, y), textcoords="offset points", xytext=(5,5), ha='left', fontsize=10, color='blue')
    plt.title("acceleration par regression lineaire")
    plt.xlabel(desc)
    plt.ylabel("acceleration $m.s^{-2}$")
    plt.legend()
    plt.grid()
    
experiences = pd.DataFrame({"id": [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48],
                            "I": [1, 1.5, 2, 2.5, 1, 1.5, 2, 2.5, 1.0, 1.5, 2.0, 2.5, 2.5, 3.0, 3, 3, 2.5, 3.0, 1.0, 2.0, 3.0, 2.5, 1.0, 2.0, 3.0, 1, 1, 2, 3, 3, 1, 1, 1, 2, 3, 3], # Courant
                            "U": [2.5, 3.2, 3.8, 4.5, 2.0, 2.7, 3.0, 3.6, 2.7, 2.7, 3.0, 3.6, 3.7, 4.4, 4.4, 4.4, 3.2, 3.6, 1.6, 2.5, 3.4, 2.9, 1.6, 2.2, 3.0, 1.6, 1.5, 2.4, 3.2, 3.2, 1.4, 1.4, 2.0, 3.0, 4.7, 3.2],                         # Tension appliqué
                            "t_debut": [[8.859, 0], [6.923] * 4, [5.896] * 3, [None] * 0, [9.066] * 2, [13.281] * 2,
                                        [7.106] * 2, [0.0] * 1, [None] * 1, [None] * 1, [None] * 1, [None] * 1, 
                                        [0, 11.621, 11.621, 0], [5.167] * 2, [9.855] * 2, [5.9]*3,  [None] * 2, [None]*2, [None] * 2,
                                        [None] * 2,  [None] * 2, [None] * 2,[None] * 1,  [None] * 1, [None] * 1,
                                        [None] * 2,  [None] * 2, [None] * 3,[None] * 2,  [None] * 2, [None] * 2, [None] * 1,
                                        [None] * 1,  [4.015] * 1, [None] * 2,[None] * 1
                                        ], #temps d'activation du moteur MHD
                            "mass": [40, 40, 40, 40, 60, 60, 60, 60, 80, 80, 60, 60, 40, 40, 40, 40, 60, 60, 75, 75, 75, 75, 100, 100, 100, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40],                                  #masse de sel ajouté
                            "V": [300 for i in range(36)],                                                             #volume d'eau
                            "e": [1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 1.5 ],                         #epaisseur en cm
                            "nb_p": [2, 4, 3, 0, 2, 2, 2, 1, 1, 1, 1, 1, 4, 2, 2, 3, 2, 2, 2, 2, 2, 2, 1, 1, 1, 2, 2, 3, 2, 2, 2, 1, 1, 1, 2, 1],                                              # nombre de pointage
                            "utilisable": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
                            
                            })

exp_datas = {}  # Initialisation du dictionnaire

for id in experiences["id"]:
    try:
        if (experiences.loc[experiences["id"] == id, "nb_p"].iloc[0] == 1 and 
            experiences.loc[experiences["id"] == id, "utilisable"].iloc[0] == 1):
            exp_datas[id] = [getFile(f"data/experience{id}.csv")]
        else:
            nb_p = experiences.loc[experiences["id"] == id, "nb_p"].iloc[0]
            utilisable = experiences.loc[experiences["id"] == id, "utilisable"].iloc[0]
            exp_datas[id] = [
                getFile(f"data/experience{id}{chr(i)}.csv") 
                for i in range(97, 97 + nb_p) * utilisable
            ]
    except Exception as e:
        print(f"\033[91mErreur pour l'ID {id}: {e}\033[0m")
        
def getAcceleration(id, index):
    # Calcul de la vitesse
    data = exp_datas[id]
    vitesse = integreXY(data[index]["x"], data[index]["y"], data[index]["t"], 10)
    # regression linéaire pour la vitesse
    t_debut = experiences.loc[experiences["id"] == id, "t_debut"].iloc[0][index] if experiences.loc[experiences["id"] == id, "t_debut"].iloc[0] else 0
    if t_debut == None: 
        t_debut = 0
    T = data[index]["t"][10:-10] - t_debut
    a, _ = linear_regOrignStart(T, vitesse, 1)
    return abs(a)

def getAccelerations():
    accelerations = {}
    for id in exp_datas.keys():
        data = exp_datas[id]
        accelerations[id] = []
        for j in range(len(data)):
            accelerations[id].append(getAcceleration(id, j))  
    return accelerations

def getAccelerationsMoyenne():
    accelerations = getAccelerations()
    accelerationsMoyenne = {}
    for id in exp_datas.keys():
        accelerationsMoyenne[id] = np.mean(accelerations[id]) 
    return accelerationsMoyenne
 
def Mean_Std_per_exp():
    # format de clé: (I, m, e)
    accels = {}
    for id, datas in exp_datas.items():
        k = (float(experiences.loc[experiences["id"] == id, "I"].iloc[0]), float(experiences.loc[experiences["id"] == id, "mass"].iloc[0]), float(experiences.loc[experiences["id"] == id, "e"].iloc[0]))
        for j in range(len(datas)): 
            if k in accels.keys(): 
                accels[k].append(getAcceleration(id, j))
            else: 
                accels[k] = []
                accels[k].append(getAcceleration(id, j))               
    mean = {key: np.mean(np.array(accels[key])) for key in accels.keys()}          
    std1 = {key: np.std(np.array(accels[key]))if len(accels[key]) >= 2 else 0 for key in accels.keys() }
    std2 = {key: np.std(np.array(accels[key]))for key in accels.keys() if len(accels[key]) >= 2 }
    return mean, std1, std2

def stdMean():
    mean, std1, std2 = Mean_Std_per_exp()
    # moyenne quadratique (RMS)
    # return np.sqrt(np.mean(np.square(list(std2.values()))))
    print(np.sqrt(np.mean(np.square(list(std2.values())))))
    print(np.mean(np.array(list(std2.values()))))
    return np.mean(np.array(list(std2.values())))
STDM  = stdMean()


def getExperience_per_key():
    experiences_per_key ={}
    for id, datas in exp_datas.items():
        k = (float(experiences.loc[experiences["id"] == id, "I"].iloc[0]), float(experiences.loc[experiences["id"] == id, "mass"].iloc[0]), float(experiences.loc[experiences["id"] == id, "e"].iloc[0]))
        for j in range(len(datas)):  
            if k in experiences_per_key.keys():
                experiences_per_key[k].append(id)
            else:
                experiences_per_key[k] = [id]
    return experiences_per_key
experiences_per_key = getExperience_per_key()



def compare_data4(var, const1, value1, const2, value2, desc="", titre=""):
    mean, std1, std2 = Mean_Std_per_exp()
    variableValue = experiences[var].unique()
    order = ["I", "mass", "e"]
    Desc = {
        "I": "I (A)",
        "mass": "Masse de sel (g)",
        "e": "Epaisseur (cm)",
        "U": "Tension appliqué (V)",
    }
    if desc == "":
        desc = Desc[var]
    if titre =="":
        titre = f"acceleration en fonction de {var} avec {const1} = {value1}, {const2} = {value2}"
    varI = order.index(var)
    c1I = order.index(const1)
    c2I = order.index(const2)
    def getKey(v):
        k = [0, 0, 0]
        k[varI] = float(v)
        k[c1I] = value1
        k[c2I] = value2
        return tuple(k)
    keys = [getKey(v) for v in variableValue if getKey(v) in mean.keys()]
    
    fig = plt.figure(figsize=(12, 6))
    X = [v for v in variableValue if getKey(v) in mean.keys()]
    Y = [mean[key] for key in keys]
    a, b = np.polyfit(X, Y, 1)
    plt.plot(X, reg(a, b)(np.array(X)), "--", label=f"y = {a:.6f}x + {b:.6f}")
    plt.errorbar(X, Y, yerr=[STDM for key in keys if key in std1.keys()], fmt='g+', capsize=5, label="incertitude")
    # plt.errorbar(X, Y, yerr=[max(std1[key], STDM) for key in keys if key in std1.keys()], fmt='g+', capsize=5, label="incertitude")
    pY = [getAcceleration(id, j) for key in keys for id in experiences_per_key[key] for j in range(len(exp_datas[id]))]
    pX = [experiences.loc[experiences["id"] == id, var].iloc[0] for key in keys for id in experiences_per_key[key] for j in range(len(exp_datas[id]))]
    # plt.plot(pX, pY, "rx", label=f"mesures")
    plt.plot(X, Y, "o", label="acceleration")
    plt.title(titre)
    plt.xlabel(desc)
    plt.ylabel("acceleration $m.s^{-2}$")
    plt.legend()
    plt.grid()
    
    
#figure: 10, 11
id = 16
exp_datas[id][0]
fig = plt.figure(figsize=(8, 6))
plt.plot(exp_datas[16][0]["t"], exp_datas[id][0]["y"], label="pointage")
plt.xlabel("temps (s)")
plt.ylabel("position y (m)")
plt.title("Position y pour ID 16")
plt.legend()
plt.grid()
fig = plt.figure(figsize=(8, 6))
data = exp_datas[id]
t_debut = experiences.loc[experiences["id"] == id, "t_debut"].iloc[0][0] if experiences.loc[experiences["id"] == id, "t_debut"].iloc[0] else 0
if t_debut == None: 
    t_debut = 0
vitesse = integreXY(data[0]["x"], data[0]["y"], data[0]["t"], 10)
T = data[0]["t"][10:-10] - t_debut
a, b = linear_regOrignStart(T, vitesse, 1)
plt.plot(T, vitesse, label=f"vitesse après integration et filtrage {0 + 1}")
plt.plot(T, reg(a, b)(T), "--", label=f"y = {a:.6f}x + {b:.6f}")
plt.xlabel("Temps (s)")
plt.ylabel("Vitesse ($m.s^{-1}$)")
plt.title(f"Vitesse pour ID {id}")
plt.legend()
plt.grid()

# figure : 12, 13, 14
# compare_data3([11, 12, 13, 25, 26, 27, 28, 48], experiences, exp_datas, "I", desc="I (A)") # pas mal I1
compare_data4("I", "mass", 40, "e", 1.5, titre = "acceleration en fonction de I avec m = 40g, e = 1.5cm", desc="I (A)")

# compare_data3([11, 38, 39, 43, 45], experiences, exp_datas, "e", desc="Epaisseur (cm)") #e1
# compare_data4("e", "mass", 40, "I",1, desc="Epaisseur (cm)", titre="acceleration en fonction de e avec mass = 40g, I = 1 A")

# compare_data3([11, 19, 31, 35], experiences, exp_datas, "mass", desc="Masse de sel (g)") # m1   #15
# compare_data4("mass", "I", 1, "e", 1.5, desc="Masse de sel (g)", titre="acceleration en fonction de m avec I = 1A, e = 1.5cm")


compare_data4("mass", "I", 3, "e", 1.5, titre="acceleration en fonction de M avec I = 3A, e = 1.5cm") # m1
# figure : 15


def U_I(): 
    conductance = {}
    # Exclure la masse 80g
    filtered_experience = experiences[experiences["mass"] != 80]
    exclude = [48, 25, 26, 27, 28, 29, 30]
    filtered_experiences = filtered_experience[~filtered_experience["id"].isin(exclude)]
    unique_epaisseurs = filtered_experiences["e"].unique()
    unique_masses = filtered_experiences["mass"].unique()
    colors = plt.cm.viridis(np.linspace(0, 1, len(unique_masses)))
    markers = ['o', 's', '^', 'D', 'v', 'P', '*', 'X', '<', '>', 'h', 'H', 'p', '8']

    n_rows = 1
    n_cols = len(unique_epaisseurs)
    # Créez 3 figures séparées, une pour chaque épaisseur unique
    figs_axes = []
    for idx in range(n_cols):
        fig, ax = plt.subplots(figsize=(8, 6))
        figs_axes.append((fig, ax))
    axes = [ax for fig, ax in figs_axes]
    if n_cols == 1:
        axes = [axes]

    for idx, ep in enumerate(unique_epaisseurs):
        ax = axes[idx]
        mask_ep = filtered_experiences["e"] == ep
        regression_done = set()
        for i, (mass, color) in enumerate(zip(unique_masses, colors)):
            mask = mask_ep & (filtered_experiences["mass"] == mass)
            U = filtered_experiences.loc[mask, "U"]
            I = filtered_experiences.loc[mask, "I"]
            ids = filtered_experiences.loc[mask, "id"]
            if len(U) == 0:
                continue
            marker = markers[i % len(markers)]
            ax.plot(U, I, marker, label=f"m = {mass}g", color=color, linestyle='None')
            ax.errorbar(U, I, xerr=0.1, yerr=0.1, marker=marker, color=color, linestyle='None')
            ## Affiche le numéro de l'expérience sur chaque point
            # for u, i_val, id_val in zip(U, I, ids):
            #     ax.annotate(str(id_val), (u, i_val), textcoords="offset points", xytext=(5,5), ha='left', fontsize=10, color='blue')

            # Calcul de la droite de régression (une seule fois par masse)
            if len(U) > 1 and mass not in regression_done:
                a, b = np.polyfit(U, I, 1)
                ax.plot(U, a * U + b, "--", color=color, label=f"y = {a:.3f}x + {b:.3f}")
                regression_done.add(mass)
                key = (mass, ep)
                conductance[key] = a

        ax.set_title(f"Épaisseur e = {ep} cm")
        ax.set_xlabel("Tension (U) [V]")
        ax.set_ylabel("Courant (I) [A]")
        ax.grid()
        ax.legend(loc="upper left")

    plt.figure(figsize=(12, 6))
    for (mass, ep), conductance_value in conductance.items():
        if mass == 40:
            plt.plot(1/ep, conductance_value, 'o', label=f"m = {mass}g, e = {ep}cm")
    plt.title("Conductance en fonction de l'épaisseur")
    plt.xlabel("Épaisseur (cm)")
    plt.ylabel("Conductance (S)")
    plt.legend()
    plt.grid()
    
    fig = plt.figure(figsize=(12, 6))
    X = []
    Y = []
    for (mass, ep), conductance_value in conductance.items():
        if ep == 1.5:
            X.append(mass)
            Y.append(conductance_value)
    plt.plot(X, Y, 'bo', label=f"e = {ep}cm, m = {mass}g")
    a, b = np.polyfit(X, Y, 1)
    plt.plot(X, reg(a, b)(np.array(X)), "--", label=f"y = {a:.4e}x + {b:.6f}")
    plt.title("Conductance en fonction de la masse")
    plt.xlabel("Masse (g)")
    plt.ylabel("Conductance (S)")
    plt.legend()
    plt.grid()
            
# U_I()

plt.show()
